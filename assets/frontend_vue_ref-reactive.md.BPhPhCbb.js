import{_ as e,c as a,o as r,a4 as t}from"./chunks/framework.CE7GJjuD.js";const _=JSON.parse('{"title":"ref 和 reactive","description":"","frontmatter":{},"headers":[],"relativePath":"frontend/vue/ref-reactive.md","filePath":"frontend/vue/ref-reactive.md","lastUpdated":1714745250000}'),o={name:"frontend/vue/ref-reactive.md"},c=t('<h1 id="ref-和-reactive" tabindex="-1">ref 和 reactive <a class="header-anchor" href="#ref-和-reactive" aria-label="Permalink to &quot;ref 和 reactive&quot;">​</a></h1><h2 id="使用上区别" tabindex="-1">使用上区别 <a class="header-anchor" href="#使用上区别" aria-label="Permalink to &quot;使用上区别&quot;">​</a></h2><p>两者都能定义响应式数据，在什么情况下用哪种？</p><p>一般来说 <code>ref</code> 定义基本类型数据，<code>reactive</code> 定义引用类型数据</p><p><strong>而事实是根据你赋值方式来决定的，ref 也可以定义 引用类型 ，只是需要通过.value 方式修改，并且能够直接赋值，reactive 只能修改属性值，否则会失去响应式</strong></p><h2 id="ref-定义响应式数据" tabindex="-1">ref 定义响应式数据 <a class="header-anchor" href="#ref-定义响应式数据" aria-label="Permalink to &quot;ref 定义响应式数据&quot;">​</a></h2><p>如果 ref 接收的初始值时，第一步创建 RefImpl 对象，然后判断数据类型，如果是 Array 或 Object，它会调用 reactive() 进行转化 proxy <strong>对象</strong>。并保存到 _value 属性，ref 通过 es6 class 写法，定义了 get 和 set 方法</p><h2 id="reactive-定义数组和对象" tabindex="-1">reactive 定义数组和对象 <a class="header-anchor" href="#reactive-定义数组和对象" aria-label="Permalink to &quot;reactive 定义数组和对象&quot;">​</a></h2><p>reactive只能定义数组和对象，设置Proxy的get和set，get：收集依赖，set：触发更新</p><h2 id="q-a" tabindex="-1">Q&amp;A <a class="header-anchor" href="#q-a" aria-label="Permalink to &quot;Q&amp;A&quot;">​</a></h2><p>Q：为什么 ref 需要通过.value 方式修改响应式数据？<br> A：ref 是通过 new refImpl 类创建的对象，由这个对象中的 value 和对应的 set，get 方法来触发更新的，_value 保存转化的响应式数据，我们通过 .value 触发 get 方法返回 _value ，如果是直接赋值就等同于赋一个普通的值。</p><p>Q：为什么 ref 定义引用类型的响应式数据？<br> A：createRef 使先判断数据类型，如果是引用类型的话，他会调用 reactive() 将数据通过 proxy 进行包装保存到_value，也是通过.value 触发 get 去获取。</p><p>Q：使用哪种方式定义引用类型响应式数据 <br> A：取决你的修改响应式数据的方式，直接修改/通过 .value 修改</p>',13),i=[c];function n(l,s,f,d,p,v){return r(),a("div",null,i)}const u=e(o,[["render",n]]);export{_ as __pageData,u as default};
